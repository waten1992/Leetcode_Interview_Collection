/*
Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

For example,
Given n = 3, there are a total of 5 unique BST's.

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

*/

/*
---------------
别人的答案

-------------------

如果把上例的顺序改一下，就可以看出规律了。
1      1      2      3       3
 \      \    / \     /       /
  3      2  1   3   2       1
 /       \         /         \
2        3        1           2
比如，以1 为根的树的个数，等于左子树的个数乘以右子树的个数，左子树是0 个元素的树，
右子树是2 个元素的树。以2 为根的树的个数，等于左子树的个数乘以右子树的个数，左子树是1
个元素的树，右子树也是1 个元素的树。依此类推。
当数组为1; 2; 3; :::; n 时，基于以下原则的构建的BST 树具有唯一性：以i 为根节点的树，其左
子树由[1, i-1] 构成，其右子树由[i+1, n] 构成。
定义f(i) 为以[1; i] 能产生的Unique Binary Search Tree 的数目，则
如果数组为空，毫无疑问，只有一种BST，即空树，f(0) = 1。
如果数组仅有一个元素1，只有一种BST，单个节点，f(1) = 1。
如果数组有两个元素1,2，那么有如下两种可能
1       2
 \     /
  2   1

f(2) = f(0)*f(1) ，1 为根的情况
        + f(1)*f(0) ，2 为根的情况
        
再看一看3 个元素的数组，可以发现BST 的取值方式如下：
f(3) = f(0)*f(2) ，1 为根的情况
        + f(1)*f(1) ，2 为根的情况
        + f(2)*f(0) ，3 为根的情况
所以，由此观察，可以得出f 的递推公式为
f(i) =Σf(k-1)*f(i-k) // 从k = 1开始 
至此，问题划归为一维动态规划。

Runtime: 2 ms
*/

class Solution
{
public:
    int numTrees(int n)
    {
        vector<int> f(n+1, 0); //初始化n+1个数为零
        f[0] = 1; //为空树时一种情况
        f[1] = 1;//为一个根节点的情况
        for (int i = 2; i <= n; ++i)
        {
            for (int k = 1; k <= i; ++k)
                f[i] += f[k-1] * f[i - k];
        }
        return f[n];
    }
};